<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Tetris</title>
<style>
@media (min-width: 769px) {
            body::before {
                content: "Mobile-only. Use on phone.";
                display: flex;
                align-items: center;
                justify-content: center;
                height: 100vh;
                font-family: sans-serif;
                font-size: 18px;
                color: #555;
                background: #f0f0f0;
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                z-index: 9999;
            }
            body > * { display: none !important; }
        }
body {
  margin: 0;
  padding: 0;
  background: #222;
  font-family: Arial;
  touch-action: manipulation;
  overflow: hidden;
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
}
#game {
  display: flex;
  height: 80vh;
  max-height: 600px;
  max-width: 800px;
  margin: 0 auto;
}
#board {
height: 600px;
  width: 400px;
  background: #111;
  display: grid;
  grid-template: repeat(20, 1fr) / repeat(10, 1fr);
  gap: 1px;
  padding: 2px;
}
.cell {
  background: #333;
}
#panel {
  height: 600px;
  width: 200px;
  background: #444;
  color: #fff;
  padding: 5px;
  overflow: auto;
  font-size: 12px;
  box-sizing: border-box;
  // border: 1px;
  margin-top: 2px;
}
.btn {
  background: #555;
  color: #fff;
  border: none;
  padding: 12px 8px;  
  margin: 3px 0;
  border-radius: 3px;
  font-size: 12px;
  cursor: pointer;
  min-height: 40px;  
  width: 100%;   
  align-items: center;
  justify-content: center;
}
.btn:active {
  background: #777;
}
#next {
  display: grid;
  grid-template: repeat(4, 1fr) / repeat(4, 1fr);
  gap: 1px;
  background: #333;
  height: 60px;
  width: 60px;
  margin: 5px 0;
}
.next-cell {
  background: #444;
}
#controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 3px;
  margin-top: 5px;
}
@media (max-width: 600px) {
  #game {
    width: 100%;
    height: 90vh;
    max-height: none;
  }
  #board, #panel {
    font-size: 10px;
  }
  .btn {
    padding: 4px;
    font-size: 15px;
  }
}
</style>
</head>
<body>
<div id="game">
  <div id="board"></div>
  <div id="panel">
    <div>Score: <span id="score">0</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Lines: <span id="lines">0</span></div>
    <div>Next:</div>
    <div id="next"></div>
    <button id="start" class="btn">Start</button>
    <button id="pause" class="btn">Pause</button>
    <div id="controls">
      <button id="left" class="btn">←</button>
      <button id="right" class="btn">→</button>
      <button id="down" class="btn">↓</button>
      <button id="rotate" class="btn">↻</button>
    </div>
  </div>
</div>

<script>
// Game setup
const COLS=10,ROWS=20,EMPTY=0;
const SHAPES=[[],
 [[1,1,1,1]],[[1,1],[1,1]],[[0,1,0],[1,1,1]],
 [[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,0,0],[1,1,1]],[[0,0,1],[1,1,1]]];
const COLORS=['#000','#0ff','#ff0','#a0f','#f00','#0f0','#f80','#00f'];

let board=[],current,next,score=0,level=1,lines=0,gameInt=null,paused=false,over=false,dropSpeed=1000;

// DOM elements
const boardEl=document.getElementById('board'),nextEl=document.getElementById('next'),
      scoreEl=document.getElementById('score'),levelEl=document.getElementById('level'),
      linesEl=document.getElementById('lines'),startBtn=document.getElementById('start'),
      pauseBtn=document.getElementById('pause'),leftBtn=document.getElementById('left'),
      rightBtn=document.getElementById('right'),downBtn=document.getElementById('down'),
      rotateBtn=document.getElementById('rotate');

// Initialize game
function init() {
  createBoard();
  nextPiece();
  
  // Event listeners
  startBtn.addEventListener('click',startGame);
  pauseBtn.addEventListener('click',togglePause);
  leftBtn.addEventListener('click',()=>move(-1,0));
  rightBtn.addEventListener('click',()=>move(1,0));
  downBtn.addEventListener('click',()=>move(0,1));
  rotateBtn.addEventListener('click',()=>rotate(1));
  
  // Touch controls
  let startX=0,startY=0;
  boardEl.addEventListener('touchstart',(e)=>{
    startX=e.touches[0].clientX;
    startY=e.touches[0].clientY;
    e.preventDefault();
  },{passive:false});
  boardEl.addEventListener('touchmove',(e)=>{
    if(!startX||!startY)return;
    const dx=e.touches[0].clientX-startX;
    const dy=e.touches[0].clientY-startY;
    if(Math.abs(dx)>Math.abs(dy)) {
      if(dx>10)move(1,0);
      else if(dx<-10)move(-1,0);
    } else {
      if(dy>10)move(0,1);
      else if(dy<-10)rotate(1);
    }
    e.preventDefault();
  },{passive:false});
  
  // Keyboard controls
  document.addEventListener('keydown',(e)=>{
    if(paused||over)return;
    switch(e.key) {
      case 'ArrowLeft':move(-1,0);break;
      case 'ArrowRight':move(1,0);break;
      case 'ArrowDown':move(0,1);break;
      case 'ArrowUp':rotate(1);break;
      case ' ':hardDrop();break;
      case 'z':case 'Z':rotate(-1);break;
    }
  });
}

function createBoard() {
  board=Array(ROWS).fill().map(()=>Array(COLS).fill(EMPTY));
  boardEl.innerHTML='';
  for(let r=0;r<ROWS;r++) {
    for(let c=0;c<COLS;c++) {
      const cell=document.createElement('div');
      cell.className='cell';
      cell.id=`c${r}-${c}`;
      boardEl.appendChild(cell);
    }
  }
  nextEl.innerHTML='';
  for(let r=0;r<4;r++) {
    for(let c=0;c<4;c++) {
      const cell=document.createElement('div');
      cell.className='next-cell';
      cell.id=`n${r}-${c}`;
      nextEl.appendChild(cell);
    }
  }
}

function startGame() {
  if(gameInt)clearInterval(gameInt);
  createBoard();
  score=0;level=1;lines=0;over=false;paused=false;dropSpeed=1000;
  updateScore();
  nextPiece();
  spawnPiece();
  gameInt=setInterval(()=>{if(!paused)move(0,1)},dropSpeed);
  startBtn.textContent='Restart';
  pauseBtn.textContent='Pause';
}

function togglePause() {
  if(over)return;
  paused=!paused;
  pauseBtn.textContent=paused?'Resume':'Pause';
}

function nextPiece() {
  const i=Math.floor(Math.random()*7)+1;
  next={shape:SHAPES[i],color:COLORS[i],x:0,y:0};
  clearNext();
  showNext();
}

function spawnPiece() {
  current={shape:next.shape,color:next.color,
           x:Math.floor(COLS/2)-Math.floor(next.shape[0].length/2),y:0};
  if(collision()) {
    gameOver();
    return;
  }
  nextPiece();
  draw();
}

function move(dx,dy) {
  if(paused||over)return;
  current.x+=dx;
  current.y+=dy;
  if(collision()) {
    current.x-=dx;
    current.y-=dy;
    if(dy===1) {
      lock();
      clearLines();
      spawnPiece();
    }
    return false;
  }
  draw();
  return true;
}

function hardDrop() {
  if(paused||over)return;
  while(move(0,1)){}
}

function rotate(dir) {
  if(paused||over)return;
  const oShape=current.shape,oX=current.x;
  const rows=current.shape.length,cols=current.shape[0].length;
  const newShape=Array(cols).fill().map(()=>Array(rows).fill(0));
  for(let r=0;r<rows;r++) {
    for(let c=0;c<cols;c++) {
      if(dir===1)newShape[c][rows-1-r]=current.shape[r][c];
      else newShape[cols-1-c][r]=current.shape[r][c];
    }
  }
  current.shape=newShape;
  if(collision()) {
    const kicks=[-1,1,-2,2];
    for(const k of kicks) {
      current.x+=k;
      if(!collision())break;
      current.x-=k;
    }
    if(collision()) {
      current.shape=oShape;
      current.x=oX;
    }
  }
  draw();
}

function collision() {
  for(let r=0;r<current.shape.length;r++) {
    for(let c=0;c<current.shape[r].length;c++) {
      if(current.shape[r][c]) {
        const x=current.x+c,y=current.y+r;
        if(x<0||x>=COLS||y>=ROWS||(y>=0&&board[y][x]))return true;
      }
    }
  }
  return false;
}

function lock() {
  for(let r=0;r<current.shape.length;r++) {
    for(let c=0;c<current.shape[r].length;c++) {
      if(current.shape[r][c]) {
        const y=current.y+r,x=current.x+c;
        if(y>=0)board[y][x]=current.color;
      }
    }
  }
}

function clearLines() {
  let cleared=0;
  for(let r=ROWS-1;r>=0;r--) {
    if(board[r].every(c=>c)) {
      board.splice(r,1);
      board.unshift(Array(COLS).fill(EMPTY));
      cleared++;
      r++;
    }
  }
  if(cleared>0) {
    lines+=cleared;
    score+=[0,40,100,300,1200][cleared]*level;
    const newLvl=Math.floor(lines/10)+1;
    if(newLvl>level) {
      level=newLvl;
      dropSpeed=Math.max(100,1000-(level-1)*100);
      clearInterval(gameInt);
      gameInt=setInterval(()=>{if(!paused)move(0,1)},dropSpeed);
    }
    updateScore();
  }
}

function draw() {
  for(let r=0;r<ROWS;r++) {
    for(let c=0;c<COLS;c++) {
      document.getElementById(`c${r}-${c}`).style.backgroundColor=board[r][c]||'#333';
    }
  }
  for(let r=0;r<current.shape.length;r++) {
    for(let c=0;c<current.shape[r].length;c++) {
      if(current.shape[r][c]) {
        const y=current.y+r,x=current.x+c;
        if(y>=0&&y<ROWS&&x>=0&&x<COLS) {
          document.getElementById(`c${y}-${x}`).style.backgroundColor=current.color;
        }
      }
    }
  }
}

function showNext() {
  const cx=Math.floor(4/2)-Math.floor(next.shape[0].length/2);
  const cy=Math.floor(4/2)-Math.floor(next.shape.length/2);
  for(let r=0;r<next.shape.length;r++) {
    for(let c=0;c<next.shape[r].length;c++) {
      if(next.shape[r][c]) {
        const y=cy+r,x=cx+c;
        if(y>=0&&y<4&&x>=0&&x<4) {
          document.getElementById(`n${y}-${x}`).style.backgroundColor=next.color;
        }
      }
    }
  }
}

function clearNext() {
  for(let r=0;r<4;r++) {
    for(let c=0;c<4;c++) {
      document.getElementById(`n${r}-${c}`).style.backgroundColor='#444';
    }
  }
}

function updateScore() {
  scoreEl.textContent=score;
  levelEl.textContent=level;
  linesEl.textContent=lines;
}

function gameOver() {
  over=true;
  clearInterval(gameInt);
  alert(`Game Over! Score: ${score}`);
}

window.onload=init;
</script>
</body>
</html>